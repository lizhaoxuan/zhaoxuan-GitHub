#更节约的网络架构设计


在做Android性能优化时，其中很重要的一块便是网络通讯优化。那是否可以依照网络优化原则，去设计一个更为“节省”的网络框架？

==================


##设计原则

网络优化的核心原则其实很简单，只有两点：

 - 更少的网络请求
 
 - 更少的数据传输量
 
 那么从这两点出发，可以引出我们这次网络架构设计的几个核心点：
 
 - **请求合并**
 
 - **返回携带**
 
 - **基于时间戳的增量更新**
 
 - 线程池核心线程数的动态调控
 
 - 任务的AOP切面管理与取消控制
 
 - 优先级插队策略
 
 - 依赖权重的请求重试
 
 - 可配置的缓存机制
 
 - 支持取消操作
 

 
 


####1.请求合并

**实现更少的网络请求**

**灵感来源1：**

我的第一个项目的网络设计：服务端**只给客户端暴露一个接口**。客户端在请求的JSON数据包中表明当前请求类型。

**灵感来源2：**

目前应用都在以Restful架构设计。因为每一类资源都有其对应的URL，所以**不同的资源请求都在单独发送**。例如：应用开启后，可能需要向服务端发送N种验证信息（软件更新、AndFix path信息、当前用户通知等等）。
这是一种非常低效且损耗电量的使用。

你有考虑过，如此多的多余请求真的不可避免吗？


**请求合并：** 依然基于Restful架构，但服务端提供唯一的合并接口。
另外其他所有资源的单独接口均可单独请求。

- 同一时间发送的多条请求均走合并接口，在合并接口中附带各个子请求的url。由服务端进行解析或分发，然后返回客户端一个Message List。
- 其他所有独立请求，依然遵循现有架构独立请求。（毕竟服务端解析与分发也是有性能损耗的）

新的数据包格式：

	{
		"code": 0,  //错误码
		"msg": "success",
		"msg_list":[
			{
				"type":1,
				"code":0,//返回错误码
				"msg":"",
				"data":{
					//type1的数据包
				}
			},
			{
				"type":2,
				"code":0,//返回错误码
				"msg":"",
				"data":{
					//type2的数据包
				}
			}

	}

 
####2.返回携带
**缓解推送不稳定的痛点**


**灵感来源1：** 轮询下的信箱与邮递员机制。

（信箱与邮递员：在无推送服务情况下，服务端将要发送给客户端信息存储到专属于此客户端“信箱中”，等待客户端索取。客户端定时轮询请求服务端，拿空信箱所有数据，得到一个消息列表，然后依照消息类型依次解析。）

**灵感来源2：** 请求浪费与推送不稳定。

大部分基于RESTful架构设计的应用，各类资源都有单独URL，相互互不影响。而大部分需要定位服务的应用，都有定时上传位置信息的轮询需求实现。

由此引发的现状是什么呢？

这边在不停的轮询上传位置信息，那边还再等推送服务推来的消息，等到推来了再去拉。

推送的不稳定性已经成了家常便饭，丢失的信息也就只能认命的丢失了……



**返回携带：** 
所有的普通请求除拿回目标数据以外，还将携带回服务端积累的推送信息。

依然基于RESTful架构设计。但是返回数据包需要修改：

	{
		"code":0, //错误码
		"msg":"success",
		"data":{
			//请求的数据包
		},
		"msg_list":[
			{
				"type":1,
				"code":0,//返回错误码
				"msg":"",
				"data":{
					//type1的数据包
				}
			},
			{
				"type":2,
				"code":0,//返回错误码
				"msg":"",
				"data":{
					//type2的数据包
				}
			}
			...
		]
	}


每一次请求都会携带回服务端积存的数据包，去掉多余的请求与推送需求。

携带回所有需要依赖推送的数据包，解决推送不稳定。

**但并不是说推送就不需要了，返回携带是一道双保险。**

推送不再区分类型，仅是通知应用去服务端拉去数据。

对推送消息分级：

- 紧急类：立刻推送，推送成功后，在信箱中清楚。

- 普通类：延迟推送，在积累实践达到上限或数据量达到某个上限进行推送。

- 非紧急类：不再推送，仅堆积到信箱中。等待未来某一次的索取。

信箱的每一次“访问“都会清空信箱所有内容。




####基于时间戳的增量更新

在不得不请求的情况下，减少数据包大小。**更少的数据传输量**

一个较为尴尬的现象：更新并不频繁，却又需要尽量保持同步的信息：用户信息，好友列表，消息列表。

目前的解决方案有哪些呢？

- 打开相应页面后，覆盖更新。（如果没有变动，就是一次浪费了）
- 依赖推送服务。（推送的接受率实在让人汗颜）

**基于时间戳的增量更新原理：**

时间戳由服务器计算（避免在客户端计算时间不准确）。

客户端服务器双方数据库的每类数据都有最后更新时间字段，客户端携带当前最后更新时间戳进行请求，服务端比对双方时间戳差，只有在服务端时间大于客户端时间的情况下才返回相应数据。


####线程池核心线程数的动态调控

线程池会一直维护核心线程。数量越多越消耗手机性能。数量少又将影响并发效率。

提高核心线程数，将提高并发效率，但数量越多越消耗性能。
减少核心线程数，并发效率会降低，但多出的任务会被安排到等待队列，这里的任务是可以被取消的，增加了可控性。

我的策略是这样安排的：

	private static final int maxCount = Runtime.getRuntime().availableProcessors() * 2;

	int corePoolSize = 0;
	
	if(数据流量)
		corePoolSize = maxCount / 3 
	if（wifi）
		corePoolSize = maxCount / 3 * 2;
	if（充电）
		corePoolSize += maxCount / 3 
	
		
	this.mTaskThreadPool.setCorePoolSize(corePoolSize);

####任务的AOP切面管理与取消控制

对网络任务的开发了更多的定制化接口，而在这之上，也就给开发者更多的选择。比如：AOP。

- 在线程池中任务的取消一直都是一个问题，除了等待队列中的任务可以随意操作，一般在线程池中正在执行的线程已经很难再去做取消控制了，AOP虽然不能完全解决问题，但最起码给了我们一点选择的可能。

- 同样，我们也可以将Loading等的控制权上移至网络框架，减少工作量。

先看示例代码，具体应用我们将在最后的项目代码中详述：

	public abstract class BaseTask implements Runnable {

		//任务执行前
    	public boolean before(){
    		//Loading等提示启动
    		//某些逻辑处理判断是否继续执行
    	}
    
    	public abstract void running();
    
    	@Override
    	public void run(){
        	if(before()){
        		running();
        		after();
        	}
    	}
    	
    	//任务执行后
    	public void after(){
    		//Loading消失
    		//逻辑判断：是否给予回调
    		//将结果回调回主线程
    	}
    }
 


####优先级插队策略

这个没有什么好说的，大部分网络框架都有。根据请求类型的重要程度，在等待队列中插队到前方。


建议不要设置级别过多，导致管理混乱。“一超多强”的策略较为合适。

（只有极少量高优先级请求，其他请求都一样）

####依赖权重的请求重试

在某些无限制的连续请求重试情况下，不停的打Log信息与网络请求，将会极大的影响手机性能。

某些关键路径请求，仅两次的请求重试可能并不能满足需求。

根据业务需求，动态配置请求重试参数。


####可配置的缓存机制

设立二级缓存：内存缓存与硬盘缓存。

内存缓存保存路径较深的时效性较高数据，如好友的个人信息。

硬盘缓存保存短路径数据，结合*基于时间戳的增量更新*策略。

依照业务需求，对网络任务进行配置。















